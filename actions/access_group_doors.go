package actions

import (
	"doory/models"
	"fmt"
	"log"
	"net/http"

	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/pop/v5"
	"github.com/gobuffalo/x/responder"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (AccessGroupDoor)
// DB Table: Plural (access_group_doors)
// Resource: Plural (AccessGroupDoors)
// Path: Plural (/access_group_doors)
// View Template Folder: Plural (/templates/access_group_doors/)

// AccessGroupDoorsResource is the resource for the AccessGroupDoor model
type AccessGroupDoorsResource struct {
	buffalo.Resource
}

// Create adds a AccessGroupDoor to the DB. This function is mapped to the
// path POST /token_access_groups
func (v AccessGroupDoorsResource) Create(c buffalo.Context) error {

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	log.Println("access_group_id:", c.Param("access_group_id"))
	log.Println("door_id:", c.Param("door_id"))
	accessGroup := &models.AccessGroup{}
	// To find the AccessGroup the parameter access_group_id is used.
	if err := tx.Find(accessGroup, c.Param("access_group_id")); err != nil {
		return c.Error(http.StatusNotFound, err)
	}

	door := &models.Door{}
	// To find the door the parameter door_id is used.
	if err := tx.Find(door, c.Param("door_id")); err != nil {
		return c.Error(http.StatusNotFound, err)
	}

	name := fmt.Sprintf("Door-%s", door.ID)

	// Door checked?
	if c.Param(name) == "true" {
		// Allocate Door
		AccessGroupDoor := &models.AccessGroupDoor{
			AccessGroupID: accessGroup.ID,
			DoorID:        door.ID,
		}

		// Validate the data from the html form
		verrs, err := tx.ValidateAndCreate(AccessGroupDoor)

		if err != nil {
			return err
		}
		if verrs.HasAny() {
			return responder.Wants("html", func(c buffalo.Context) error {
				// Make the errors available inside the html template
				c.Set("errors", verrs)

				// Render again the new.html template that the user can
				// correct the input.
				c.Set("AccessGroupDoor", AccessGroupDoor)

				return c.Render(http.StatusUnprocessableEntity, r.HTML("/access_groups/%s/edit/", c.Param("access_group_id")))
			}).Wants("json", func(c buffalo.Context) error {
				return c.Render(http.StatusUnprocessableEntity, r.JSON(verrs))
			}).Wants("xml", func(c buffalo.Context) error {
				return c.Render(http.StatusUnprocessableEntity, r.XML(verrs))
			}).Respond(c)
		}

		return responder.Wants("html", func(c buffalo.Context) error {
			// If there are no errors set a success message
			data := map[string]interface{}{
				"AccessGroup": accessGroup.Name,
				"Building":    door.Building,
				"Floor":       door.Floor,
				"Room":        door.Room,
				"Company":     door.Company,
			}
			c.Flash().Add("success", T.Translate(c, "access_group_door.created.success", data))

			// and redirect to the show page
			return c.Redirect(http.StatusSeeOther, "/access_groups/%v/edit/", c.Param("access_group_id"))
		}).Wants("json", func(c buffalo.Context) error {
			return c.Render(http.StatusCreated, r.JSON(AccessGroupDoor))
		}).Wants("xml", func(c buffalo.Context) error {
			return c.Render(http.StatusCreated, r.XML(AccessGroupDoor))
		}).Respond(c)

		// AccessGroup unchecked
	} else {
		AccessGroupDoor := &models.AccessGroupDoor{}
		if err := tx.Where("door_id = ? and access_group_id = ?", door.ID, accessGroup.ID).First(AccessGroupDoor); err != nil {
			return c.Error(http.StatusNotFound, err)
		}
		err := tx.Destroy(AccessGroupDoor)
		if err != nil {
			return err
		}

		return responder.Wants("html", func(c buffalo.Context) error {
			// If there are no errors set a success message
			data := map[string]interface{}{
				"AccessGroup": accessGroup.Name,
				"Building":    door.Building,
				"Floor":       door.Floor,
				"Room":        door.Room,
				"Company":     door.Company,
			}
			c.Flash().Add("success", T.Translate(c, "access_group_door.destroyed.success", data))

			// and redirect to the show page
			return c.Redirect(http.StatusSeeOther, "/access_groups/%v/edit/", c.Param("access_group_id"))
		}).Wants("json", func(c buffalo.Context) error {
			return c.Render(http.StatusOK, r.JSON(AccessGroupDoor))
		}).Wants("xml", func(c buffalo.Context) error {
			return c.Render(http.StatusOK, r.XML(AccessGroupDoor))
		}).Respond(c)
	}
}

// List gets all AccessGroupDoors. This function is mapped to the path
// GET /token_access_groups
func (v AccessGroupDoorsResource) List(c buffalo.Context) error {
	return redirect_not_implemented(c, "List")
}

// Show gets the data for one AccessGroupDoor. This function is mapped to
// the path GET /token_access_groups/{token_access_group_id}
func (v AccessGroupDoorsResource) Show(c buffalo.Context) error {
	return redirect_not_implemented(c, "Show")
}

// New renders the form for creating a new AccessGroupDoor.
// This function is mapped to the path GET /token_access_groups/new
func (v AccessGroupDoorsResource) New(c buffalo.Context) error {
	return redirect_not_implemented(c, "New")
}

// Update changes a AccessGroupDoor in the DB. This function is mapped to
// the path PUT /token_access_groups/{token_access_group_id}
func (v AccessGroupDoorsResource) Update(c buffalo.Context) error {
	return redirect_not_implemented(c, "Update")
}

// Edit renders a edit form for a AccessGroupDoor. This function is
// mapped to the path GET /token_access_groups/{token_access_group_id}/edit
func (v AccessGroupDoorsResource) Edit(c buffalo.Context) error {
	return redirect_not_implemented(c, "Edit")
}

// Destroy deletes a AccessGroupDoor from the DB. This function is mapped
// to the path DELETE /token_access_groups/{token_access_group_id}
func (v AccessGroupDoorsResource) Destroy(c buffalo.Context) error {
	return redirect_not_implemented(c, "Destroy")
}
