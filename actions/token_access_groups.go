package actions

import (
	"doors/models"
	"fmt"
	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/pop/v5"
	"github.com/gobuffalo/x/responder"
	"log"
	"net/http"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (TokenAccessGroup)
// DB Table: Plural (token_access_groups)
// Resource: Plural (TokenAccessGroups)
// Path: Plural (/token_access_groups)
// View Template Folder: Plural (/templates/token_access_groups/)

// TokenAccessGroupsResource is the resource for the TokenAccessGroup model
type TokenAccessGroupsResource struct {
	buffalo.Resource
}

// Create adds a TokenAccessGroup to the DB. This function is mapped to the
// path POST /token_access_groups
func (v TokenAccessGroupsResource) Create(c buffalo.Context) error {

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	accessGroup := &models.AccessGroup{}
	// To find the AccessGroup the parameter access_group_id is used.
	if err := tx.Find(accessGroup, c.Param("access_group_id")); err != nil {
		return c.Error(http.StatusNotFound, err)
	}
	log.Println("AccessGroup:", accessGroup)

	token := &models.Token{}
	// To find the Token the parameter token_id is used.
	if err := tx.Find(token, c.Param("token_id")); err != nil {
		return c.Error(http.StatusNotFound, err)
	}
	log.Println("Token:", token)

	name := fmt.Sprintf("AccessGroup-%s", accessGroup.ID)

	// AccessGroup checked?
	if c.Param(name) == "true" {
		// Allocate TokenAccessGroup
		tokenAccessGroup := &models.TokenAccessGroup{
			TokenID:       token.ID,
			AccessGroupID: accessGroup.ID,
		}

		// Validate the data from the html form
		verrs, err := tx.ValidateAndCreate(tokenAccessGroup)

		if err != nil {
			return err
		}
		if verrs.HasAny() {
			return responder.Wants("html", func(c buffalo.Context) error {
				// Make the errors available inside the html template
				c.Set("errors", verrs)

				// Render again the new.html template that the user can
				// correct the input.
				c.Set("tokenAccessGroup", tokenAccessGroup)

				return c.Render(http.StatusUnprocessableEntity, r.HTML("/token_access_groups/new.plush.html"))
			}).Wants("json", func(c buffalo.Context) error {
				return c.Render(http.StatusUnprocessableEntity, r.JSON(verrs))
			}).Wants("xml", func(c buffalo.Context) error {
				return c.Render(http.StatusUnprocessableEntity, r.XML(verrs))
			}).Respond(c)
		}

		return responder.Wants("html", func(c buffalo.Context) error {
			// If there are no errors set a success message
			data := map[string]interface{}{
				"Name":  accessGroup.Name,
				"Token": token.TokenID,
			}
			c.Flash().Add("success", T.Translate(c, "token_access_group.created.success", data))
			//log.Println("TokenAccessGroup:", tokenAccessGroup)

			// and redirect to the show page
			return c.Redirect(http.StatusSeeOther, "/people/%v/tokens/%v/edit/", c.Param("Person"), token.ID)
		}).Wants("json", func(c buffalo.Context) error {
			return c.Render(http.StatusCreated, r.JSON(tokenAccessGroup))
		}).Wants("xml", func(c buffalo.Context) error {
			return c.Render(http.StatusCreated, r.XML(tokenAccessGroup))
		}).Respond(c)

		// AccessGroup unchecked
	} else {
		tokenAccessGroup := &models.TokenAccessGroup{}
		if err := tx.Where("token_id = ? and access_group_id = ?", token.ID, accessGroup.ID).First(tokenAccessGroup); err != nil {
			return c.Error(http.StatusNotFound, err)
		}
		err := tx.Destroy(tokenAccessGroup)
		if err != nil {
			return err
		}

		return responder.Wants("html", func(c buffalo.Context) error {
			// If there are no errors set a success message
			data := map[string]interface{}{
				"Name":  accessGroup.Name,
				"Token": token.TokenID,
			}
			c.Flash().Add("success", T.Translate(c, "token_access_group.destroyed.success", data))

			// and redirect to the show page
			return c.Redirect(http.StatusSeeOther, "/people/%v/tokens/%v/edit/", c.Param("Person"), token.ID)
		}).Wants("json", func(c buffalo.Context) error {
			return c.Render(http.StatusOK, r.JSON(tokenAccessGroup))
		}).Wants("xml", func(c buffalo.Context) error {
			return c.Render(http.StatusOK, r.XML(tokenAccessGroup))
		}).Respond(c)
	}
}

// List gets all TokenAccessGroups. This function is mapped to the path
// GET /token_access_groups
func (v TokenAccessGroupsResource) List(c buffalo.Context) error {
	return redirect_not_implemented(c, "List")
}

// Show gets the data for one TokenAccessGroup. This function is mapped to
// the path GET /token_access_groups/{token_access_group_id}
func (v TokenAccessGroupsResource) Show(c buffalo.Context) error {
	return redirect_not_implemented(c, "Show")
}

// New renders the form for creating a new TokenAccessGroup.
// This function is mapped to the path GET /token_access_groups/new
func (v TokenAccessGroupsResource) New(c buffalo.Context) error {
	return redirect_not_implemented(c, "New")
}

// Update changes a TokenAccessGroup in the DB. This function is mapped to
// the path PUT /token_access_groups/{token_access_group_id}
func (v TokenAccessGroupsResource) Update(c buffalo.Context) error {
	return redirect_not_implemented(c, "Update")
}

// Edit renders a edit form for a TokenAccessGroup. This function is
// mapped to the path GET /token_access_groups/{token_access_group_id}/edit
func (v TokenAccessGroupsResource) Edit(c buffalo.Context) error {
	return redirect_not_implemented(c, "Edit")
}

// Destroy deletes a TokenAccessGroup from the DB. This function is mapped
// to the path DELETE /token_access_groups/{token_access_group_id}
func (v TokenAccessGroupsResource) Destroy(c buffalo.Context) error {
	return redirect_not_implemented(c, "Destroy")
}
